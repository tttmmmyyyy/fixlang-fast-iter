module StaticIter;

// The trait Iterable is a trait for types that can be iterated over.
trait iter : Iterable {
    type Item iter;
    advance : iter -> Option (iter, Item iter);
}

/*
    Folding and looping.
*/

// Folds the elements of an iterable from left to right.
//
// Conceptually, `[a0, a1, a2, ...].fold(s, op) = s.op(a0).op(a1).op(a2)...`.
fold : [iter : Iterable, Item iter = a] s -> (a -> s -> s) -> iter -> s;
fold = |s, op, iter| (
    match iter.advance {
        none() => s,
        some((iter, a)) => iter.fold(op(a, s), op)
    }
);

// Loop over the elements of an iterable.
// 
// This function is similar to `fold` but a more general version of it. It allows the user to break out of the loop early.
loop_iter : [iter : Iterable, Item iter = a] s -> (a -> s -> LoopState s s) -> iter -> s;
loop_iter = |s, body, iter| (
    match iter.advance {
        none() => s,
        some((iter, a)) => match body(a, s) {
            break(s) => s,
            continue(s) => iter.loop_iter(s, body),
        }
    }
);

/*
    Conversion from / to arrays.
*/

// Converts an iterator to an array.
to_array : [iter : Iterable, Item iter = a] iter -> Array a;
to_array = |iter| iter.fold([], |a, acc| acc.push_back(a));

type ArrayIterator a = unbox struct { arr : Array a, idx : I64 };

impl ArrayIterator a : Iterable {
    type Item (ArrayIterator a) = a;
    advance = |ArrayIterator { arr : arr, idx : idx }| (
        if idx == arr.get_size { none() };
        let v = arr.@(idx);
        some((ArrayIterator { arr: arr, idx: idx + 1 }, v))
    );
}

// Converts an array to an iterator.
from_array : Array a -> ArrayIterator a;
from_array = |arr| ArrayIterator { arr: arr, idx: 0 };

type RangeIterator = unbox struct { next : I64, end : I64 };

impl RangeIterator : Iterable {
    type Item RangeIterator = I64;
    advance = |RangeIterator { next : next, end : end }| (
        if next == end { Option::none() }
        else { Option::some $ (RangeIterator { next: next + 1, end: end }, next) }
    );
}

/*
    Basic iterators.
*/

type EmptyIterator a = unbox struct {};
impl EmptyIterator a : Iterable {
    type Item (EmptyIterator a) = a;
    advance = |_| none();
}

// An iterator that yields no elements.
empty : EmptyIterator a;
empty = EmptyIterator {};

// Creates an iterator that generates a range of numbers.
// 
// `range(a, b)` generates a range of numbers from `a` to `b - 1`.
// 
// If `a` is greater than or equal to `b`, the iterator will an infinite sequence of `a`.
range : I64 -> I64 -> RangeIterator;
range = |start, end| RangeIterator { next: start, end: end };

type MapIterator i a b = unbox struct { iter : i, f : a -> b };
impl [i : Iterable, Item i = a] MapIterator i a b : Iterable {
    type Item (MapIterator i a b) = b;
    advance = |MapIterator { iter : iter, f : f }| (
        match iter.advance {
            none() => none(),
            some((iter, a)) => some((MapIterator { iter: iter, f: f }, f(a)))
        }
    );
}

type CountUpIterator = unbox struct { next : I64 };
impl CountUpIterator : Iterable {
    type Item CountUpIterator = I64;
    advance = |CountUpIterator { next : next }| some((CountUpIterator { next: next + 1 }, next));
}

// Creates an iterator that counts up from a number.
// 
// `count_up(start)` generates an infinite sequence of numbers starting from `start`.
count_up : I64 -> CountUpIterator;
count_up = |start| CountUpIterator { next: start };

/*
    Extract information from iterators.
*/

// Gets the number of elements in an iterator.
get_size : [iter : Iterable] iter -> I64;
get_size = |iter| iter.fold(0, |_, acc| acc + 1);

// Maps a function over an iterator.
// 
// `iter.map(f)` returns an iterator that applies `f` to each element of `iter`.
map : [i : Iterable, Item i = a] (a -> b) -> i -> MapIterator i a b;
map = |f, iter| MapIterator { iter: iter, f: f };

type FilterIterator i a = unbox struct { iter : i, pred : a -> Bool };
impl [i : Iterable, Item i = a] FilterIterator i a : Iterable {
    type Item (FilterIterator i a) = Item i;
    advance = |FilterIterator { iter : iter, pred : pred }| (
        match iter.advance {
            none() => none(),
            some((iter, a)) => if pred(a) { 
                some((FilterIterator { iter: iter, pred: pred }, a))
            } else {
                FilterIterator { iter: iter, pred: pred }.advance
            }
        }
    );
}

// Filters the elements of an iterator by a predicate.
// 
// `iter.filter(pred)` returns an iterator that only yields elements of `iter` for which `pred` returns `true`.
filter : [i : Iterable, Item i = a] (a -> Bool) -> i -> FilterIterator i a;
filter = |pred, iter| FilterIterator { iter: iter, pred: pred };

type FlattenIterator i2 i1 = unbox struct { i2 : i2, i1 : Option i1 };
impl [i2 : Iterable, i1: Iterable, Item i2 = i1] FlattenIterator i2 i1 : Iterable {
    type Item (FlattenIterator i2 i1) = Item i1;
    advance = |FlattenIterator { i2 : i2, i1 : i1 }| (
        match i1 {
            none() => (
                match i2.advance {
                    none() => none(),
                    some((i2, i1)) => FlattenIterator { i2: i2, i1: some(i1) }.advance
                }
            ),
            some(i1) => (
                match i1.advance {
                    none() => FlattenIterator { i2: i2, i1: none() }.advance,
                    some((i1, a)) => some $ (FlattenIterator { i2: i2, i1: some(i1) }, a)
                }
            )
        }
    );
}

// Flattens an iterator of iterators.
flatten : [i2 : Iterable, i1 : Iterable, Item i2 = i1] i2 -> FlattenIterator i2 i1;
flatten = |i2| FlattenIterator { i2: i2, i1: none() };

type ProductIterator i1 i2 a b = unbox struct { iter1 : i1, iter2 : i2, e2 : Option b, iter1_org : i1 };
impl [i1 : Iterable, i2 : Iterable, Item i1 = a, Item i2 = b] ProductIterator i1 i2 a b : Iterable {
    type Item (ProductIterator i1 i2 a b) = (Item i1, Item i2);
    advance = |ProductIterator { iter1 : iter1, iter2 : iter2, e2 : e2, iter1_org : iter1_org }| (
        match e2 {
            some(e2) => (
                match iter1.advance {
                    some((iter1, e1)) => some $ (ProductIterator { iter1: iter1, iter2: iter2, e2: some(e2), iter1_org : iter1_org }, (e1, e2)),
                    none() => match iter2.advance {
                        none() => none(),
                        some((iter2, e2)) => ProductIterator { iter1: iter1_org, iter2: iter2, e2: some(e2), iter1_org : iter1_org }.advance
                    },
                }
            ),
            none() => (
                match iter2.advance {
                    none() => none(),
                    some((iter2, e2)) => ProductIterator { iter1: iter1, iter2: iter2, e2: some(e2), iter1_org : iter1_org }.advance
                }
            ),
        }
    );
}

// Creates an iterator that yields the Cartesian product of two iterators.
// 
// NOTE: Since this function is designed so that `iter1.product(iter2)` yields the Cartesian product, the elements of `product(iter2, iter1)` are in the opposite order.
// 
// Example:
// ```
// assert_eq(|_|"", range(1, 4).product(['a', 'b'].from_array).to_array, [(1, 'a'), (2, 'a'), (3, 'a'), (1, 'b'), (2, 'b'), (3, 'b')]);;
// ```
product : [i1 : Iterable, i2 : Iterable, Item i1 = a, Item i2 = b] i2 -> i1 -> ProductIterator i1 i2 a b;
product = |iter2, iter1| ProductIterator { iter1: iter1, iter2: iter2, e2: none(), iter1_org: iter1 };

type AppendIterator i1 i2 = unbox struct { iter1 : Option i1, iter2 : i2 };

impl [i1 : Iterable, i2 : Iterable, Item i1 = a, Item i2 = a] AppendIterator i1 i2 : Iterable {
    type Item (AppendIterator i1 i2) = Item i2;
    advance = |AppendIterator { iter1 : iter1, iter2 : iter2 }| (
        match iter1 {
            none() => (
                match iter2.advance {
                    none() => none(),
                    some((iter2, a)) => some $ (AppendIterator { iter1: none(), iter2: iter2 }, a)
                }
            ),
            some(iter1) => (
                match iter1.advance {
                    none() => AppendIterator { iter1: none(), iter2: iter2 }.advance,
                    some((iter1, a)) => some $ (AppendIterator { iter1: some(iter1), iter2: iter2 }, a)
                }
            )
        }
    );
}

// Appends two iterators.
// 
// NOTE: Since this function is designed so that `iter1.append(iter2)` appends `iter2` after `iter1`, `append(iter1, iter2)` appends iterators in the opposite order.
append : [i1 : Iterable, i2 : Iterable, Item i1 = a, Item i2 = a] i2 -> i1 -> AppendIterator i1 i2;
append = |iter2, iter1| AppendIterator { iter1 : some(iter1), iter2 : iter2 };

// type StateIterator s a = unbox struct {
//     state : Option s,
//     transit : s -> Option (s, a)
// };

// namespace StateIterator {
//     make : s -> (s -> Option (s, a)) -> StateIterator s a;
//     make = |state, transit| StateIterator { state: some(state), transit: transit };

//     empty : StateIterator s a;
//     empty = StateIterator { state: none(), transit: |s| none() };
// }

// impl StateIterator s a : Iterable {
//     type Item (StateIterator s a) = a;    
//     advance = |StateIterator { state : s, transit : f }| (
//         match s {
//             none() => none(),
//             some(s) => match f(s) {
//                 none() => none(),
//                 some((s, a)) => some((StateIterator::make(s, f), a))
//             }
//         }
//     );
// }

// to_state : [iter: Iterable, Item iter = a] iter -> StateIterator iter a;
// to_state = |iter| StateIterator::make(iter, |iter| iter.advance);

type DynamicIterator a = unbox struct { next : () -> Option (DynamicIterator a, a) };

namespace DynamicIterator {
    empty : DynamicIterator a;
    empty = DynamicIterator { next: |_| none() };
}

impl DynamicIterator a : Iterable {
    type Item (DynamicIterator a) = a;
    advance = |DynamicIterator { next : next }| next();
}

to_dyn : [iter : Iterable, Item iter = a] iter -> DynamicIterator a;
to_dyn = |iter| DynamicIterator { next: |_| (
    match iter.advance {
        none() => none(),
        some((iter, a)) => some((iter.to_dyn, a))
    }
) };

// flatten_dyn : DynamicIterator (DynamicIterator a) -> FlattenIterator (DynamicIterator (DynamicIterator a)) (DynamicIterator a);
// flatten_dyn = |i| i.StaticIter::flatten;

// impl DynamicIterator : Monad {
//     pure = |a| DynamicIterator::empty;
//     bind = |f, xs| xs.map(f).flatten.to_dyn;
// }